// Piano-Hammer// ï¿½2006 Thomas Resch// www.zippernoise.net// ported to c from Stefan Belbao's Prepared Piano																									/*																									    *//*-------------------------------------------struct t_bowtable----------------------------------------------*//*																										*/#include "t_pianoHammer.h"#include "ext.h"#include "ext_obex.h"	// required for new style Max object#include "ext_common.h"#include "z_dsp.h"#include "math.h"#include "buffer.h"#include <Accelerate/Accelerate.h>#include "t_std.h"t_pianoHammer *t_pianoHammer_new(double hammerInitPosition_, double hammerFrequency_, double hammerMassDensityRatio_, double hammerVelocity_, int NS_){	t_pianoHammer *x = (t_pianoHammer *) sysmem_newptrclear(sizeof(t_pianoHammer));		x->hammerInitPosition = hammerInitPosition_;	x->hammerFrequency = hammerFrequency_;	x->hammerMassDensityRatio = hammerMassDensityRatio_;	x->hammerVelocity = hammerVelocity_;	x->lastHammer = x->hammerInitPosition;	x->nextHammer = 0;	x->hammerContact = 0;	x->hammerOn = 0;	x->NS = NS_;	//x->hammerPosition = (double *)sysmem_newptrclear(sizeof(double)*x->NS);	//x->hammerForce = (double *)sysmem_newptrclear(sizeof(double)*x->NS);	x->normHammerIndex = 0.5;	return x;}void t_pianoHammer_free(t_pianoHammer *x){	sysmem_freeptr(x);	}void t_pianoHammer_reset(t_pianoHammer *x){	x->hammerOn = 0;	/*x->hammerContact = 0;	x->lastHammer = x->hammerInitPosition;	x->hammer = x->hammerInitPosition + (x->dt) * x->hammerVelocity;	x->nextHammer = 0;*/	}void t_pianoHammer_calculateHammerIndex(t_pianoHammer *x){	x->hammerIndex = 2+floor(x->normHammerIndex/x->dx);}void t_pianoHammer_set_dxdt(t_pianoHammer *x, double dx_, double dt_){	x->dt = dt_;	x->dt_2 = pow(x->dt,2);	x->dx = dx_;	x->hammer = x->hammerInitPosition + (x->dt) * x->hammerVelocity;	x->hammerIndex = 2+floor(x->normHammerIndex/x->dx);}/* if(hammer_on==1)        % do this while a strike is occurring        pos = w1(hammer_index,:)-ham1;        pos = 0.5*(pos-abs(pos));        hammer_force = (abs(pos)).^3;;                        if(min(pos)<0)            % turns on force contact with string            hammer_contact = 1;        end        if((hammer_contact==1)&(min(pos)==0))            % if hammer has been in contact, but now no longer is, turn off            % hammer updating            hammer_on=0;hammer_contact=0;        end                ham = 2*ham1-ham2-dt^2*sum(hammer_force)*(2*pi*hammer(2))^2;                ham2 = ham1;         ham1 = ham;        w(hammer_index,:) = w(hammer_index,:)+dt^2*hammer(1)*(2*pi*hammer(2))^2*hammer_force;        hammerout(n) = ham;hammerforceout(n) = sum(hammer_force);    end */void t_pianoHammer_perform(t_pianoHammer *x, double ***nextString, double ***string)    // input{	int i;	if(x->hammerOn == 1)	{		for(i=0;i<x->NS;i++)		{			x->hammerPosition[i] = (*string)[i][x->hammerIndex] - x->hammer;			x->hammerPosition[i] = 0.5*(x->hammerPosition[i] - fabs(x->hammerPosition[i]));			x->hammerForce[i] = pow((fabs(x->hammerPosition[i])), 3);		}				if(t_fmin(x->hammerPosition, x->NS)<0)			x->hammerContact = 1;					if((x->hammerContact == 1) && (t_fmin(x->hammerPosition, x->NS) == 0))		{			x->hammerOn = 0; x->hammerContact = 0;		}			x->nextHammer = 2*x->hammer-x->lastHammer-x->dt_2*t_fsum(x->hammerForce, x->NS)*pow(2*PI*x->hammerFrequency,2);		x->lastHammer = x->hammer;		x->hammer = x->nextHammer;			for(i=0;i<x->NS;i++)		{			(*nextString)[i][x->hammerIndex] = (*nextString)[i][x->hammerIndex] + x->dt_2*x->hammerMassDensityRatio*pow(2*PI*x->hammerFrequency,2)*x->hammerForce[i];		}	}}