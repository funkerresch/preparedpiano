// Piano-Rubber// by Thomas Resch// ported to c from Stefan Belbao's Prepared Piano																									/*																									    *//*---/Users/harveykeitel/Repositories/preparedpiano/src/t_trap.c----------------------------------------struct t_rubber----------------------------------------------*//*																										*/#include "t_rubber.h"#include "ext.h"#include "ext_obex.h"	// required for new style Max object#include "ext_common.h"#include "z_dsp.h"#include "math.h"t_rubber *t_rubber_new(double rubberFrequency_, double rubberMassDensityRatio_, double rubberLoss_, int NS_){	t_rubber *x = (t_rubber *) sysmem_newptrclear(sizeof(t_rubber));	x->rubberFrequency = rubberFrequency_;	x->rubberMassDensityRatio = rubberMassDensityRatio_;	x->rubber = 0;	x->nextRubber = 0;	x->rubberOn = 0;	x->NS = NS_;	//x->rubberForce = (double *) sysmem_newptrclear(sizeof(double)*x->NS);	//x->rubberPosition = (double *) sysmem_newptrclear(sizeof(double)*x->NS);	x->rubberLoss = rubberLoss_;	x->w_2 = pow(2*PI*x->rubberFrequency,2);	x->normRubberIndex = 0.5;    x->rubberIndex = 2;		return x;}void t_rubber_free(t_rubber *x){	sysmem_freeptr(x);	}void t_rubber_calculateRubberIndex(t_rubber *x, double normRubberIndex_){	x->normRubberIndex = normRubberIndex_;	x->rubberIndex = 2+floor(x->normRubberIndex/x->dx);   // post("index: %d", x->rubberIndex);	}void t_rubber_setRubberParameters(t_rubber *x, double fundamentalFreq, double massDensityRatio, double rubberLoss){		int state = x->rubberOn;	x->rubberOn = 0;          //turn rubber off while changing any parameters.....	x->lastRubber = 0;	x->rubber = 0;	x->nextRubber = 0;	if(fundamentalFreq>0)		x->rubberFrequency = fundamentalFreq;	if(massDensityRatio>0)		x->rubberMassDensityRatio = massDensityRatio;	if(rubberLoss>0)		x->rubberLoss = rubberLoss;	x->w_2 = pow(2*PI*x->rubberFrequency,2);	x->rubberLoss_mul_dt_over2_plus1 = 1+x->rubberLoss*x->dt_over2; 	x->one_minus_rubberLoss_mul_dt_over2 = 1-x->rubberLoss*x->dt_over2;	x->rubberOn = state;	//go back to previous rubber state	}void t_rubber_set_dxdt(t_rubber *x, double dx_, double dt_){	x->dx = dx_;	x->dt = dt_;	x->dt_2 = pow(x->dt,2);	x->dt_over2 = x->dt * 0.5;	x->rubberLoss_mul_dt_over2_plus1 = 1+x->rubberLoss*x->dt_over2; 	x->one_minus_rubberLoss_mul_dt_over2 = 1-x->rubberLoss*x->dt_over2;	x->rubberIndex = 2+floor(x->normRubberIndex/x->dx);	}void t_rubber_reset(t_rubber *x){	int state = x->rubberOn;	x->rubberOn = 0;          //turn rubber off while changing any parameters.....	x->lastRubber = 0;	x->rubber = 0;	x->nextRubber = 0;	//x->rubberPosition = 0;	//x->rubberForce = 0;	x->rubberOn = state;}void t_rubber_perform(t_rubber *x, double ***nextString, double ***string)    // input is string at rubberIndex...{	int i;        if(x->rubberIndex >= 1000)        return;        if(x->rubberIndex < 0)        return;    	if(x->rubberOn == 1)	{		for(i=0;i<x->NS;i++)		{			x->rubberPosition[i] = (*string)[i][x->rubberIndex] - x->rubber;			x->rubberForce[i] = 0.5*(x->rubberPosition[i]-fabs(x->rubberPosition[i]));			(*nextString)[i][x->rubberIndex] = (*nextString)[i][x->rubberIndex] - pow(x->dt,2)*x->w_2*x->rubberMassDensityRatio*x->rubberForce[i];		}		x->nextRubber = 2*x->rubber/(x->rubberLoss_mul_dt_over2_plus1)-(x->one_minus_rubberLoss_mul_dt_over2)*x->lastRubber/(1+x->rubberLoss*x->dt_over2) + 						x->w_2*x->dt_2*(-x->rubber+t_fsum(x->rubberForce, x->NS))/(x->rubberLoss_mul_dt_over2_plus1);		x->lastRubber = x->rubber;		x->rubber = x->nextRubber;				}	}